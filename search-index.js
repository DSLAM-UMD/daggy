var searchIndex = {};
searchIndex["daggy"] = {"doc":"**daggy** is a directed acyclic graph data structure library.","items":[[3,"EdgeIndex","daggy","Edge identifier.",null,null],[3,"NodeIndex","","Node identifier.",null,null],[3,"EdgeWeightsMut","","Iterator yielding mutable access to all edge weights.",null,null],[3,"NodeWeightsMut","","Iterator yielding mutable access to all node weights.",null,null],[3,"Dag","","A Directed acyclic graph (DAG) data structure.",null,null],[3,"Children","","A **Walker** type that can be used to step through the children of some parent node.",null,null],[3,"Parents","","A **Walker** type that can be used to step through the children of some parent node.",null,null],[3,"EdgeIndices","","An iterator yielding multiple `EdgeIndex`s, returned by the `Graph::add_edges` method.",null,null],[3,"WouldCycle","","An error returned by the `Dag::add_edge` method in the case that adding an edge would have\ncaused the graph to cycle.",null,null],[12,"0","","",0,null],[0,"walker","","**Walker** is a trait providing a variety of useful methods for traversing graph types.",null,null],[3,"Recursive","daggy::walker","Recursively walks a graph using the recursive function `recursive_fn`.",null,null],[3,"Chain","","Walks the entirety of `a` before walking the entirety of `b`.",null,null],[3,"Filter","","A walker that applies some given predicate to each element returned by its walker.\nThe only index pairs that will be yielded are those that make the predicate evaluate to true.",null,null],[3,"Peekable","","A walker that has a `.peek(&amp;graph)` method that returns an optional next neighbor.",null,null],[3,"SkipWhile","","A walker that invokes the predicate on elements until it returns false. Once the predicate\nreturns false, that element and all further elements are yielded.",null,null],[3,"TakeWhile","","A walker that yields elements so long as the predicate returns true. After the\npredicate returns false for the first time, no further elements will be yielded.",null,null],[3,"Skip","","A walker that skips the first n steps of this walk, and then yields all further steps.",null,null],[3,"Take","","A walker that yields the first n steps of this walk.",null,null],[3,"Cycle","","A walker that repeats its internal walker endlessly.",null,null],[3,"Inspect","","A walker that calls a function with a reference to each index pair before yielding them.\nThis is often useful for debugging a walker pipeline.",null,null],[3,"Iter","","An iterator yielding index pairs produced by its internal walker and graph.",null,null],[3,"IterEdges","","An iterator yielding edge indices produced by its internal walker and graph.",null,null],[3,"IterNodes","","An iterator yielding node indices produced by its internal walker and graph.",null,null],[3,"IterWeights","","An iterator yielding weights associated with the index pairs produced by its internal walker\nand graph.",null,null],[3,"IterEdgeWeights","","An iterator yielding edge weights associated with the indices produced by its internal walker\nand graph.",null,null],[3,"IterNodeWeights","","An iterator yielding node weights associated with the indices produced by its internal walker\nand graph.",null,null],[6,"IndexPair","","Short-hand for an edge node index pair.",null,null],[8,"Walker","","A trait providing a variety of useful methods for traversing some graph type **G**.",null,null],[16,"Index","","The unsigned integer type used for node and edge indices.",1,null],[10,"next","","Fetch the `EdgeIndex` and `NodeIndex` to the next neighbour in our walk through the given\n**Graph**.",1,null],[11,"next_edge","","The next edge in our walk for the given **Graph**.",1,null],[11,"next_node","","The next node in our walk for the given **Graph**.",1,null],[11,"count","","Counts all the steps in the entire walk of the given graph.",1,null],[11,"last","","Walks the whole walk until reaching and returning the last edge node pair.",1,null],[11,"last_edge","","Walks the whole walk until reaching and returning the last edge.",1,null],[11,"last_node","","Walks the whole walk until reaching and returning the last node.",1,null],[11,"nth","","Walks &quot;n&quot; number of steps and produces the resulting edge node pair.",1,null],[11,"nth_edge","","Walks &quot;n&quot; number of steps and produces the resulting edge.",1,null],[11,"nth_node","","Walks &quot;n&quot; number of steps and produces the resulting node.",1,null],[11,"chain","","Produces a walker that will walk the entirey of `self` before walking the entirey of other.",1,null],[11,"filter","","Creates a walker that applies the predicate to each element returned by this walker.\nThe only elements that will be yielded are those that make the predicate evaluate to true.",1,null],[11,"peekable","","Creates a walker that has a `.peek(&amp;graph)` method that returns an optional next neighbor.",1,null],[11,"skip_while","","Creates a walker that invokes the predicate on elements until it returns false. Once the\npredicate returns false, that element and all further elements are yielded.",1,null],[11,"take_while","","Creates a walker that yields elements so long as the predicate returns true. After the\npredicate returns false for the first time, no further elements will be yielded.",1,null],[11,"skip","","Creates a walker that skips the first n steps of this walk, and then yields all further\nsteps.",1,null],[11,"take","","Creates a walker that yields the first n steps of this walk.",1,null],[11,"all","","Tests whether the predicate holds true for all steps in the walk.",1,null],[11,"any","","Tests whether any step in the walk satisfies the given predicate.",1,null],[11,"find","","Returns the first edge node index pair satisfying the specified predicate.",1,null],[11,"find_edge","","Returns the edge index satisfying the specified predicate.",1,null],[11,"find_node","","Returns the node index satisfying the specified predicate.",1,null],[11,"cycle","","Repeats the walker endlessly.",1,null],[11,"fold","","Performs a fold operation over the entire walker, returning the eventual state at the end\nof the walk.",1,null],[11,"inspect","","Creates a walker that calls a function with a reference to each index pair before yielding\nthem. This is often useful for debugging a walker pipeline.",1,null],[11,"iter","","Converts the walker into an iterator yielding index pairs.",1,null],[11,"iter_weights","","Converts the walker into an iterator yielding `(&amp;e, &amp;n)`, where `e` is the edge weight for\nthe next `EdgeIndex` and `n` is the node weight for the next `NodeIndex`.",1,null],[11,"clone","","",2,null],[11,"fmt","","",2,null],[11,"new","","Construct a new **Recursive** **Walker** starting from the node at the given index.",2,{"inputs":[{"name":"nodeindex"},{"name":"f"}],"output":{"name":"self"}}],[11,"next","","",2,null],[11,"clone","","",3,null],[11,"fmt","","",3,null],[11,"next","","",3,null],[11,"clone","","",4,null],[11,"fmt","","",4,null],[11,"next","","",4,null],[11,"clone","","",5,null],[11,"fmt","","",5,null],[11,"peek","","The edge node index pair of the neighbor at the next step in our walk of the given graph.",5,null],[11,"peek_edge","","The edge index of the neighbor at the next step in our walk of the given graph.",5,null],[11,"peek_node","","The node index of the neighbor at the next step in our walk of the given graph.",5,null],[11,"next","","",5,null],[11,"clone","","",6,null],[11,"fmt","","",6,null],[11,"next","","",6,null],[11,"clone","","",7,null],[11,"fmt","","",7,null],[11,"next","","",7,null],[11,"clone","","",8,null],[11,"fmt","","",8,null],[11,"next","","",8,null],[11,"clone","","",9,null],[11,"fmt","","",9,null],[11,"next","","",9,null],[11,"clone","","",10,null],[11,"fmt","","",10,null],[11,"next","","",10,null],[11,"clone","","",11,null],[11,"fmt","","",11,null],[11,"next","","",11,null],[11,"clone","","",12,null],[11,"fmt","","",12,null],[11,"edges","","Convert to an iterator that only yields the edge indices.",12,null],[11,"nodes","","Convert to an iterator that only yields the node indices.",12,null],[11,"next","","",12,null],[11,"clone","","",13,null],[11,"fmt","","",13,null],[11,"next","","",13,null],[11,"clone","","",14,null],[11,"fmt","","",14,null],[11,"next","","",14,null],[11,"clone","","",15,null],[11,"fmt","","",15,null],[11,"edges","","Convert to an iterator yielding only the edge weights.",15,null],[11,"nodes","","Convert to an iterator yielding only the node weights.",15,null],[11,"next","","",15,null],[11,"clone","","",16,null],[11,"fmt","","",16,null],[11,"next","","",16,null],[11,"clone","","",17,null],[11,"fmt","","",17,null],[11,"next","","",17,null],[6,"PetGraph","daggy","The Petgraph to be used internally within the Dag for storing/managing nodes and edges.",null,null],[6,"RawNodes","","Read only access into a **Dag**&#39;s internal node array.",null,null],[6,"RawEdges","","Read only access into a **Dag**&#39;s internal edge array.",null,null],[6,"RecursiveWalk","","An alias to simplify the **Recursive** **Walker** type returned by **Dag**.",null,null],[11,"clone","","",18,null],[11,"fmt","","",18,null],[11,"clone","","",0,null],[11,"fmt","","",0,null],[11,"new","","Create a new, empty `Dag`.",18,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Create a new `Dag` with estimated capacity for its node and edge Vecs.",18,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"clear","","Removes all nodes and edges from the **Dag**.",18,null],[11,"node_count","","The total number of nodes in the **Dag**.",18,null],[11,"edge_count","","The total number of edgees in the **Dag**.",18,null],[11,"graph","","Borrow the `Dag`&#39;s underlying `PetGraph&lt;N, Ix&gt;`.\nAll existing indices may be used to index into this `PetGraph` the same way they may be\nused to index into the `Dag`.",18,null],[11,"into_graph","","Take ownership of the `Dag` and return the internal `PetGraph`.\nAll existing indices may be used to index into this `PetGraph` the same way they may be\nused to index into the `Dag`.",18,null],[11,"add_node","","Add a new node to the `Dag` with the given weight.",18,null],[11,"add_edge","","Add a new directed edge to the `Dag` with the given weight.",18,null],[11,"add_edges","","Adds the given directed edges to the `Dag`, each with their own given weight.",18,null],[11,"update_edge","","Update the edge from nodes `a` -&gt; `b` with the given weight.",18,null],[11,"find_edge","","Find and return the index to the edge that describes `a` -&gt; `b` if there is one.",18,null],[11,"edge_endpoints","","Access the parent and child nodes for the given `EdgeIndex`.",18,null],[11,"clear_edges","","Remove all edges.",18,null],[11,"add_parent","","Add a new edge and parent node to the node at the given `NodeIndex`.\nReturns both the edge&#39;s `EdgeIndex` and the node&#39;s `NodeIndex`.",18,null],[11,"add_child","","Add a new edge and child node to the node at the given `NodeIndex`.\nReturns both the edge&#39;s `EdgeIndex` and the node&#39;s `NodeIndex`.",18,null],[11,"node_weight","","Borrow the weight from the node at the given index.",18,null],[11,"node_weight_mut","","Mutably borrow the weight from the node at the given index.",18,null],[11,"raw_nodes","","Read from the internal node array.",18,null],[11,"node_weights_mut","","An iterator yielding mutable access to all node weights.",18,null],[11,"edge_weight","","Borrow the weight from the edge at the given index.",18,null],[11,"edge_weight_mut","","Mutably borrow the weight from the edge at the given index.",18,null],[11,"raw_edges","","Read from the internal edge array.",18,null],[11,"edge_weights_mut","","An iterator yielding mutable access to all edge weights.",18,null],[11,"index_twice_mut","","Index the `Dag` by two indices.",18,null],[11,"remove_node","","Remove the node at the given index from the `Dag` and return it if it exists.",18,null],[11,"remove_edge","","Remove an edge and return its weight, or `None` if it didn&#39;t exist.",18,null],[11,"parents","","A **Walker** type that may be used to step through the parents of the given child node.",18,null],[11,"children","","A &quot;walker&quot; object that may be used to step through the children of the given parent node.",18,null],[11,"recursive_walk","","A **Walker** type that recursively walks the **Dag** using the given `recursive_fn`.",18,null],[11,"index","","",18,null],[11,"index_mut","","",18,null],[11,"index","","",18,null],[11,"index_mut","","",18,null],[11,"next","","",19,null],[11,"next","","",20,null],[11,"next","","",21,null],[11,"fmt","","",0,null],[11,"description","","",0,null],[11,"new","","",22,{"inputs":[{"name":"usize"}],"output":{"name":"edgeindex"}}],[11,"index","","",22,null],[11,"end","","An invalid `EdgeIndex` used to denote absence of an edge, for example\nto end an adjacency list.",22,{"inputs":[],"output":{"name":"edgeindex"}}],[11,"hash","","",23,null],[11,"hash","","",22,null],[11,"from","","",23,{"inputs":[{"name":"ix"}],"output":{"name":"nodeindex"}}],[11,"fmt","","",23,null],[11,"fmt","","",22,null],[11,"cmp","","",23,null],[11,"cmp","","",22,null],[11,"eq","","",23,null],[11,"ne","","",23,null],[11,"eq","","",22,null],[11,"ne","","",22,null],[11,"default","","",23,{"inputs":[],"output":{"name":"nodeindex"}}],[11,"default","","",22,{"inputs":[],"output":{"name":"edgeindex"}}],[11,"clone","","",23,null],[11,"clone","","",22,null],[11,"partial_cmp","","",23,null],[11,"lt","","",23,null],[11,"le","","",23,null],[11,"gt","","",23,null],[11,"ge","","",23,null],[11,"partial_cmp","","",22,null],[11,"lt","","",22,null],[11,"le","","",22,null],[11,"gt","","",22,null],[11,"ge","","",22,null],[11,"index","","",23,null],[11,"is_node_index","","",23,{"inputs":[],"output":{"name":"bool"}}],[11,"index","","",22,null],[11,"is_node_index","","",22,{"inputs":[],"output":{"name":"bool"}}],[11,"next","","",24,null],[11,"size_hint","","",24,null],[11,"next","","",25,null],[11,"size_hint","","",25,null],[11,"new","","",23,{"inputs":[{"name":"usize"}],"output":{"name":"nodeindex"}}],[11,"index","","",23,null],[11,"end","","",23,{"inputs":[],"output":{"name":"nodeindex"}}]],"paths":[[3,"WouldCycle"],[8,"Walker"],[3,"Recursive"],[3,"Chain"],[3,"Filter"],[3,"Peekable"],[3,"SkipWhile"],[3,"TakeWhile"],[3,"Skip"],[3,"Take"],[3,"Cycle"],[3,"Inspect"],[3,"Iter"],[3,"IterEdges"],[3,"IterNodes"],[3,"IterWeights"],[3,"IterEdgeWeights"],[3,"IterNodeWeights"],[3,"Dag"],[3,"Children"],[3,"Parents"],[3,"EdgeIndices"],[3,"EdgeIndex"],[3,"NodeIndex"],[3,"NodeWeightsMut"],[3,"EdgeWeightsMut"]]};
searchIndex["petgraph"] = {"doc":"**petgraph** is a graph data structure library.","items":[[4,"Direction","petgraph","Edge direction.",null,null],[13,"Outgoing","","An `Outgoing` edge is an outward edge *from* the current node.",0,null],[13,"Incoming","","An `Incoming` edge is an inbound edge *to* the current node.",0,null],[4,"Directed","","Marker type for a directed graph.",null,null],[4,"Undirected","","Marker type for an undirected graph.",null,null],[0,"algo","","Graph algorithms.",null,null],[3,"DfsSpace","petgraph::algo","Workspace for a graph traversal.",null,null],[5,"is_isomorphic","","[Graph] Return `true` if the graphs `g0` and `g1` are isomorphic.",null,{"inputs":[{"name":"graph"},{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_isomorphic_matching","","[Graph] Return `true` if the graphs `g0` and `g1` are isomorphic.",null,{"inputs":[{"name":"graph"},{"name":"graph"},{"name":"f"},{"name":"g"}],"output":{"name":"bool"}}],[5,"dijkstra","","[Generic] Dijkstra&#39;s shortest path algorithm.",null,{"inputs":[{"name":"g"},{"name":"nodeid"},{"name":"option"},{"name":"f"}],"output":{"name":"hashmap"}}],[5,"connected_components","","[Generic] Return the number of connected components of the graph.",null,{"inputs":[{"name":"g"}],"output":{"name":"usize"}}],[5,"is_cyclic_undirected","","[Generic] Return `true` if the input graph contains a cycle.",null,{"inputs":[{"name":"g"}],"output":{"name":"bool"}}],[5,"is_cyclic_directed","","[Generic] Return `true` if the input directed graph contains a cycle.",null,{"inputs":[{"name":"g"},{"name":"option"}],"output":{"name":"bool"}}],[5,"toposort","","[Generic] Perform a topological sort of a directed graph.",null,{"inputs":[{"name":"g"},{"name":"option"}],"output":{"name":"vec"}}],[5,"has_path_connecting","","[Generic] Check if there exists a path starting at `from` and reaching `to`.",null,{"inputs":[{"name":"g"},{"name":"nodeid"},{"name":"nodeid"},{"name":"option"}],"output":{"name":"bool"}}],[5,"scc","","[Generic] Compute the *strongly connected components* using Kosaraju&#39;s algorithm.",null,{"inputs":[{"name":"g"}],"output":{"name":"vec"}}],[5,"tarjan_scc","","[Generic] Compute the *strongly connected components* using Tarjan&#39;s algorithm.",null,{"inputs":[{"name":"g"}],"output":{"name":"vec"}}],[5,"condensation","","[Graph] Condense every strongly connected component into a single node and return the result.",null,{"inputs":[{"name":"graph"},{"name":"bool"}],"output":{"name":"graph"}}],[5,"min_spanning_tree","","[Graph] Compute a *minimum spanning tree* of a graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"graph"}}],[11,"clone","","",1,null],[11,"fmt","","",1,null],[11,"new","","",1,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[0,"dot","petgraph","Simple graphviz dot file format output.",null,null],[3,"Dot","petgraph::dot","`Dot` implements output to graphviz .dot format for a graph.",null,null],[4,"Config","","`Dot` configuration.",null,null],[13,"NodeIndexLabel","","Use indices for node labels.",2,null],[13,"EdgeIndexLabel","","Use indices for edge labels.",2,null],[13,"EdgeNoLabel","","Use no edge labels.",2,null],[11,"new","","Create a `Dot` formatting wrapper with default configuration.",3,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"with_config","","Create a `Dot` formatting wrapper with custom configuration.",3,null],[11,"fmt","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"fmt","","",3,null],[11,"fmt","","",3,null],[0,"visit","petgraph","Graph traits and graph traversals.",null,null],[3,"Reversed","petgraph::visit","Wrapper type for walking the graph as if all edges are reversed.",null,null],[12,"0","","",4,null],[3,"ReversedEdgeRef","","An edge reference for `Reversed`.",null,null],[3,"ReversedEdgeReferences","","An iterator of edge references for `Reversed`.",null,null],[3,"AsUndirected","","Wrapper type for walking the graph as if it is undirected",null,null],[12,"0","","",5,null],[3,"Dfs","","Visit nodes of a graph in a depth-first-search (DFS) emitting nodes in\npreorder (when they are first discovered).",null,null],[12,"stack","","The stack of nodes to visit",6,null],[12,"discovered","","The map of discovered nodes",6,null],[3,"DfsIter","","An iterator for a depth first traversal of a graph.",null,null],[3,"DfsPostOrder","","Visit nodes in a depth-first-search (DFS) emitting nodes in postorder\n(each node after all its decendants have been emitted).",null,null],[12,"stack","","The stack of nodes to visit",7,null],[12,"discovered","","The map of discovered nodes",7,null],[12,"finished","","The map of finished nodes",7,null],[3,"Bfs","","A breadth first search (BFS) of a graph.",null,null],[12,"stack","","The queue of nodes to visit",8,null],[12,"discovered","","The map of discovered nodes",8,null],[3,"BfsIter","","An iterator for a breadth first traversal of a graph.",null,null],[3,"Topo","","A topological order traversal for a graph.",null,null],[11,"clone","","",4,null],[11,"node_identifiers","","",4,null],[11,"node_count","","",4,null],[11,"neighbors","","",4,null],[11,"neighbors_directed","","",4,null],[11,"externals","","",4,null],[11,"visit_map","","",4,null],[11,"reset_map","","",4,null],[11,"clone","","",9,null],[11,"fmt","","",9,null],[11,"source","","",9,null],[11,"target","","",9,null],[11,"weight","","",9,null],[11,"id","","",9,null],[11,"edge_references","","",4,null],[11,"next","","",10,null],[8,"GraphBase","","Base graph trait: defines the associated node identifier and\nedge identifier types.",null,null],[16,"NodeId","","node identifier",11,null],[16,"EdgeId","","edge identifier",11,null],[8,"GraphRef","","A copyable reference to a graph.",null,null],[8,"IntoNeighbors","","Access to the neighbors of each node",null,null],[16,"Neighbors","","",12,null],[10,"neighbors","","Return an iterator of the neighbors of node `a`.",12,null],[8,"IntoNeighborsDirected","","Access to the neighbors of each node, through incoming or outgoing edges.",null,null],[16,"NeighborsDirected","","",13,null],[10,"neighbors_directed","","",13,null],[8,"IntoNodeIdentifiers","","Access to the sequence of the graph’s `NodeId`s.",null,null],[16,"NodeIdentifiers","","",14,null],[10,"node_identifiers","","",14,null],[10,"node_count","","",14,null],[8,"IntoExternals","","Access to the graph’s nodes without edges to them (`Incoming`) or from them\n(`Outgoing`).",null,null],[16,"Externals","","",15,null],[10,"externals","","Return an iterator of all nodes with no edges in the given direction",15,null],[8,"GraphEdgeRef","","A graph that defines edge references",null,null],[16,"EdgeRef","","",16,null],[8,"EdgeRef","","An edge reference",null,null],[16,"NodeId","","",17,null],[16,"EdgeId","","",17,null],[16,"Weight","","",17,null],[10,"source","","",17,null],[10,"target","","",17,null],[10,"weight","","",17,null],[10,"id","","",17,null],[8,"IntoEdgeReferences","","Access to the sequence of the graph’s edges",null,null],[16,"EdgeReferences","","",18,null],[10,"edge_references","","",18,null],[8,"NodeIndexable","","The graph’s `NodeId`s map to indices",null,null],[10,"node_bound","","Return an upper bound of the node indices in the graph\n(suitable for the size of a bitmap).",19,null],[10,"to_index","","Convert `a` to an integer index.",19,{"inputs":[{"name":"nodeid"}],"output":{"name":"usize"}}],[8,"NodeCompactIndexable","","The graph’s `NodeId`s map to indices, in a range without holes.",null,null],[8,"VisitMap","","A mapping for storing the visited status for NodeId `N`.",null,null],[10,"visit","","Mark `a` as visited.",20,null],[10,"is_visited","","Return whether `a` has been visited before.",20,null],[8,"Visitable","","A graph that can create a map that tracks the visited status of its nodes.",null,null],[16,"Map","","The associated map type",21,null],[10,"visit_map","","Create a new visitor map",21,null],[10,"reset_map","","Reset the visitor map (and resize to new size of graph if needed)",21,null],[8,"GetAdjacencyMatrix","","Create or access the adjacency matrix of a graph.",null,null],[16,"AdjMatrix","","The associated adjacency matrix type",22,null],[10,"adjacency_matrix","","Create the adjacency matrix",22,null],[10,"is_adjacent","","Return true if there is an edge from `a` to `b`, false otherwise.",22,null],[11,"clone","","",5,null],[11,"neighbors","","",5,null],[11,"visit_map","","",5,null],[11,"reset_map","","",5,null],[11,"clone","","",6,null],[11,"fmt","","",6,null],[11,"new","","Create a new **Dfs**, using the graph&#39;s visitor map, and put **start**\nin the stack of nodes to visit.",6,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"self"}}],[11,"from_parts","","Create a `Dfs` from a vector and a visit map",6,{"inputs":[{"name":"vec"},{"name":"vm"}],"output":{"name":"self"}}],[11,"reset","","Clear the visit state",6,null],[11,"empty","","Create a new **Dfs** using the graph&#39;s visitor map, and no stack.",6,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe dfs from a particular node.",6,null],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",6,null],[11,"new","","",23,{"inputs":[{"name":"g"},{"name":"nodeid"}],"output":{"name":"self"}}],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe DFS traversal from a particular node.",23,null],[11,"next","","",23,null],[11,"size_hint","","",23,null],[11,"clone","","",23,null],[11,"clone","","",7,null],[11,"fmt","","",7,null],[11,"new","","Create a new `DfsPostOrder` using the graph&#39;s visitor map, and put\n`start` in the stack of nodes to visit.",7,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"self"}}],[11,"empty","","Create a new `DfsPostOrder` using the graph&#39;s visitor map, and no stack.",7,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"reset","","Clear the visit state",7,null],[11,"move_to","","Keep the discovered and finished map, but clear the visit stack and restart\nthe dfs from a particular node.",7,null],[11,"next","","Return the next node in the traversal, or `None` if the traversal is done.",7,null],[11,"clone","","",8,null],[11,"new","","Create a new **Bfs**, using the graph&#39;s visitor map, and put **start**\nin the stack of nodes to visit.",8,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"self"}}],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",8,null],[11,"new","","",24,{"inputs":[{"name":"g"},{"name":"nodeid"}],"output":{"name":"self"}}],[11,"next","","",24,null],[11,"size_hint","","",24,null],[11,"clone","","",24,null],[11,"clone","","",25,null],[11,"new","","Create a new `Topo`, using the graph&#39;s visitor map, and put all\ninitial nodes in the to visit list.",25,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"reset","","Clear visited state, and put all initial nodes in the to visit list.",25,null],[11,"next","","Return the next node in the current topological order traversal, or\n`None` if the traversal is at the end.",25,null],[0,"unionfind","petgraph","`UnionFind&lt;K&gt;` is a disjoint-set data structure.",null,null],[3,"UnionFind","petgraph::unionfind","`UnionFind&lt;K&gt;` is a disjoint-set data structure. It tracks set membership of *n* elements\nindexed from *0* to *n - 1*. The scalar type is `K` which must be an unsigned integer type.",null,null],[11,"fmt","","",26,null],[11,"clone","","",26,null],[11,"new","","Create a new `UnionFind` of `n` disjoint sets.",26,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"find","","Return the representative for `x`.",26,null],[11,"find_mut","","Return the representative for `x`.",26,null],[11,"union","","Unify the two sets containing `x` and `y`.",26,null],[11,"into_labeling","","Return a vector mapping each element to its representative.",26,null],[0,"prelude","petgraph","Commonly used items.",null,null],[0,"graph","","`Graph&lt;N, E, Ty, Ix&gt;` is a graph datastructure using an adjacency list representation.",null,null],[3,"Edge","petgraph::graph","The graph&#39;s edge type.",null,null],[12,"weight","","Associated edge data.",27,null],[3,"EdgeIndex","","Edge identifier.",null,null],[3,"EdgeIndices","","Iterator over the edge indices of a graph.",null,null],[3,"EdgeReference","","Reference to a `Graph` edge.",null,null],[3,"EdgeReferences","","Iterator over all edges of a graph.",null,null],[3,"EdgeWeightsMut","","Iterator yielding mutable access to all edge weights.",null,null],[3,"Edges","","Iterator over the edges of a node.",null,null],[3,"Externals","","An iterator over either the nodes without edges to them or from them.",null,null],[3,"Frozen","","`Frozen` only allows shared access (read-only) to the\nunderlying graph `G`, but it allows mutable access to its\nnode and edge weights.",null,null],[3,"Graph","","`Graph&lt;N, E, Ty, Ix&gt;` is a graph datastructure using an adjacency list representation.",null,null],[3,"Neighbors","","Iterator over the neighbors of a node.",null,null],[3,"Node","","The graph&#39;s node type.",null,null],[12,"weight","","Associated node data.",28,null],[3,"NodeIndex","","Node identifier.",null,null],[3,"NodeIndices","","Iterator over the node indices of a graph.",null,null],[3,"NodeWeightsMut","","Iterator yielding mutable access to all node weights.",null,null],[3,"WalkNeighbors","","A “walker” object that can be used to step through the edge list of a node.",null,null],[5,"edge_index","","Short version of `EdgeIndex::new`",null,{"inputs":[{"name":"usize"}],"output":{"name":"edgeindex"}}],[5,"node_index","","Short version of `NodeIndex::new`",null,{"inputs":[{"name":"usize"}],"output":{"name":"nodeindex"}}],[6,"DefaultIx","","The default integer type for node and edge indices in `Graph`.\n`u32` is the default to reduce the size of the graph&#39;s data and improve\nperformance in the common case.",null,null],[6,"DiGraph","","A `Graph` with directed edges.",null,null],[6,"UnGraph","","A `Graph` with undirected edges.",null,null],[8,"GraphIndex","","A  `GraphIndex` is a node or edge index.",null,null],[8,"IndexType","","Trait for the unsigned integer type used for node and edge indices.",null,null],[10,"new","","",29,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[10,"index","","",29,null],[10,"max","","",29,{"inputs":[],"output":{"name":"self"}}],[8,"EdgeType","petgraph","A graph&#39;s edge type determines whether is has directed edges or not.",null,null],[10,"is_directed","","",30,{"inputs":[],"output":{"name":"bool"}}],[8,"IntoWeightedEdge","","Convert an element like `(i, j)` or `(i, j, w)` into\na triple of source, target, edge weight.",null,null],[16,"NodeId","","",31,null],[10,"into_weighted_edge","","",31,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"partial_cmp","","",0,null],[11,"cmp","","",0,null],[11,"hash","","",0,null],[11,"clone","","",0,null],[11,"opposite","","Return the opposite `Direction`.",0,null],[11,"index","","Return `0` for `Outgoing` and `1` for `Incoming`.",0,null],[11,"fmt","","",32,null],[11,"clone","","",32,null],[11,"fmt","","",33,null],[11,"clone","","",33,null],[11,"is_directed","","",32,{"inputs":[],"output":{"name":"bool"}}],[11,"is_directed","","",33,{"inputs":[],"output":{"name":"bool"}}],[11,"clone","petgraph::graph","",34,null],[11,"default","","",34,{"inputs":[],"output":{"name":"nodeindex"}}],[11,"eq","","",34,null],[11,"ne","","",34,null],[11,"partial_cmp","","",34,null],[11,"lt","","",34,null],[11,"le","","",34,null],[11,"gt","","",34,null],[11,"ge","","",34,null],[11,"cmp","","",34,null],[11,"hash","","",34,null],[11,"new","","",34,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"index","","",34,null],[11,"end","","",34,{"inputs":[],"output":{"name":"self"}}],[11,"from","","",34,{"inputs":[{"name":"ix"}],"output":{"name":"self"}}],[11,"fmt","","",34,null],[11,"clone","","",35,null],[11,"default","","",35,{"inputs":[],"output":{"name":"edgeindex"}}],[11,"eq","","",35,null],[11,"ne","","",35,null],[11,"partial_cmp","","",35,null],[11,"lt","","",35,null],[11,"le","","",35,null],[11,"gt","","",35,null],[11,"ge","","",35,null],[11,"cmp","","",35,null],[11,"hash","","",35,null],[11,"new","","",35,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"index","","",35,null],[11,"end","","An invalid `EdgeIndex` used to denote absence of an edge, for example\nto end an adjacency list.",35,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",35,null],[11,"fmt","","",28,null],[11,"clone","","",28,null],[11,"next_edge","","Accessor for data structure internals: the first edge in the given direction.",28,null],[11,"fmt","","",27,null],[11,"clone","","",27,null],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",27,null],[11,"source","","Return the source node index.",27,null],[11,"target","","Return the target node index.",27,null],[11,"clone","","",36,null],[11,"clone_from","","",36,null],[11,"fmt","","",36,null],[11,"new","","Create a new `Graph` with directed edges.",36,{"inputs":[],"output":{"name":"self"}}],[11,"new_undirected","","Create a new `Graph` with undirected edges.",36,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Create a new `Graph` with estimated capacity.",36,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"node_count","","Return the number of nodes (vertices) in the graph.",36,null],[11,"edge_count","","Return the number of edges in the graph.",36,null],[11,"is_directed","","Whether the graph has directed edges or not.",36,null],[11,"add_node","","Add a node (also called vertex) with associated data `weight` to the graph.",36,null],[11,"node_weight","","Access the weight for node `a`.",36,null],[11,"node_weight_mut","","Access the weight for node `a`, mutably.",36,null],[11,"add_edge","","Add an edge from `a` to `b` to the graph, with its associated\ndata `weight`.",36,null],[11,"update_edge","","Add or update an edge from `a` to `b`.\nIf the edge already exists, its weight is updated.",36,null],[11,"edge_weight","","Access the weight for edge `e`.",36,null],[11,"edge_weight_mut","","Access the weight for edge `e`, mutably.",36,null],[11,"edge_endpoints","","Access the source and target nodes for `e`.",36,null],[11,"remove_node","","Remove `a` from the graph if it exists, and return its weight.\nIf it doesn&#39;t exist in the graph, return `None`.",36,null],[11,"remove_edge","","Remove an edge and return its edge weight, or `None` if it didn&#39;t exist.",36,null],[11,"neighbors","","Return an iterator of all nodes with an edge starting from `a`.",36,null],[11,"neighbors_directed","","Return an iterator of all neighbors that have an edge between them and\n`a`, in the specified direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",36,null],[11,"neighbors_undirected","","Return an iterator of all neighbors that have an edge between them and\n`a`, in either direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",36,null],[11,"edges","","Return an iterator of target nodes with an edge starting from `a`,\npaired with their respective edge weights.",36,null],[11,"edges_directed","","Return an iterator of all neighbors that have an edge between them and `a`,\nin the specified direction, paired with the respective edge weights.",36,null],[11,"contains_edge","","Lookup if there is an edge from `a` to `b`.",36,null],[11,"find_edge","","Lookup an edge from `a` to `b`.",36,null],[11,"find_edge_undirected","","Lookup an edge between `a` and `b`, in either direction.",36,null],[11,"externals","","Return an iterator over either the nodes without edges to them\n(`Incoming`) or from them (`Outgoing`).",36,null],[11,"node_indices","","Return an iterator over the node indices of the graph",36,null],[11,"node_weights_mut","","Return an iterator yielding mutable access to all node weights.",36,null],[11,"edge_indices","","Return an iterator over the edge indices of the graph",36,null],[11,"edge_references","","Create an iterator over all edges, in indexed order.",36,null],[11,"edge_weights_mut","","Return an iterator yielding mutable access to all edge weights.",36,null],[11,"raw_nodes","","Access the internal node array.",36,null],[11,"raw_edges","","Access the internal edge array.",36,null],[11,"into_nodes_edges","","Convert the graph into a vector of Nodes and a vector of Edges",36,null],[11,"first_edge","","Accessor for data structure internals: the first edge in the given direction.",36,null],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",36,null],[11,"index_twice_mut","","Index the `Graph` by two indices, any combination of\nnode or edge indices is fine.",36,null],[11,"reverse","","Reverse the direction of all edges",36,null],[11,"clear","","Remove all nodes and edges",36,null],[11,"clear_edges","","Remove all edges",36,null],[11,"capacity","","Return the current node and edge capacity of the graph.",36,null],[11,"reserve_nodes","","Reserves capacity for at least `additional` more nodes to be inserted in\nthe graph. Graph may reserve more space to avoid frequent reallocations.",36,null],[11,"reserve_edges","","Reserves capacity for at least `additional` more edges to be inserted in\nthe graph. Graph may reserve more space to avoid frequent reallocations.",36,null],[11,"reserve_exact_nodes","","Reserves the minimum capacity for exactly `additional` more nodes to be\ninserted in the graph. Does nothing if the capacity is already\nsufficient.",36,null],[11,"reserve_exact_edges","","Reserves the minimum capacity for exactly `additional` more edges to be\ninserted in the graph.\nDoes nothing if the capacity is already sufficient.",36,null],[11,"shrink_to_fit_nodes","","Shrinks the capacity of the underlying nodes collection as much as possible.",36,null],[11,"shrink_to_fit_edges","","Shrinks the capacity of the underlying edges collection as much as possible.",36,null],[11,"shrink_to_fit","","Shrinks the capacity of the graph as much as possible.",36,null],[11,"retain_nodes","","Keep all nodes that return `true` from the `visit` closure,\nremove the others.",36,null],[11,"retain_edges","","Keep all edges that return `true` from the `visit` closure,\nremove the others.",36,null],[11,"from_edges","","Create a new `Graph` from an iterable of edges.",36,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend_with_edges","","Extend the graph from an iterable of edges.",36,null],[11,"map","","Create a new `Graph` by mapping node and\nedge weights to new values.",36,null],[11,"filter_map","","Create a new `Graph` by mapping nodes and edges.\nA node or edge may be mapped to `None` to exclude it from\nthe resulting graph.",36,null],[11,"into_edge_type","","Convert the graph into either undirected or directed. No edge adjustments\nare done, so you may want to go over the result to remove or add edges.",36,null],[11,"next","","",37,null],[11,"next","","",38,null],[11,"clone","","",38,null],[11,"detach","","Return a “walker” object that can be used to step through the\nneighbors and edges from the origin node.",38,null],[11,"next","","",39,null],[11,"clone","","",39,null],[11,"next","","",40,null],[11,"size_hint","","",40,null],[11,"next","","",41,null],[11,"size_hint","","",41,null],[11,"index","","",36,null],[11,"index_mut","","",36,null],[11,"index","","",36,null],[11,"index_mut","","",36,null],[11,"default","","",36,{"inputs":[],"output":{"name":"self"}}],[11,"index","","",34,null],[11,"is_node_index","","",34,{"inputs":[],"output":{"name":"bool"}}],[11,"index","","",35,null],[11,"is_node_index","","",35,{"inputs":[],"output":{"name":"bool"}}],[11,"clone","","",42,null],[11,"next","","Step to the next edge and its endpoint node in the walk for graph `g`.",42,null],[11,"next_node","","",42,null],[11,"next_edge","","",42,null],[11,"clone","","",43,null],[11,"fmt","","",43,null],[11,"next","","",43,null],[11,"size_hint","","",43,null],[11,"next_back","","",43,null],[11,"clone","","",44,null],[11,"fmt","","",44,null],[11,"next","","",44,null],[11,"size_hint","","",44,null],[11,"next_back","","",44,null],[11,"clone","","",45,null],[11,"eq","","",45,null],[11,"weight","","Access the edge’s weight.",45,null],[11,"source","","",45,null],[11,"target","","",45,null],[11,"weight","","",45,null],[11,"id","","",45,null],[11,"next","","",46,null],[11,"size_hint","","",46,null],[11,"new","","",47,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"deref","","",47,null],[11,"index","","",47,null],[11,"index_mut","","",47,null],[11,"node_weight_mut","","Access the weight for node `a`, mutably.",47,null],[11,"edge_weight_mut","","Access the weight for edge `e`, mutably.",47,null],[11,"index_twice_mut","","Index the `Graph` by two indices, any combination of\nnode or edge indices is fine.",47,null],[11,"node_bound","","",36,null],[11,"to_index","","",36,{"inputs":[{"name":"nodeindex"}],"output":{"name":"usize"}}],[11,"visit_map","","",36,null],[11,"reset_map","","",36,null],[11,"visit_map","","",47,null],[11,"reset_map","","",47,null],[11,"adjacency_matrix","","",36,null],[11,"is_adjacent","","",36,null]],"paths":[[4,"Direction"],[3,"DfsSpace"],[4,"Config"],[3,"Dot"],[3,"Reversed"],[3,"AsUndirected"],[3,"Dfs"],[3,"DfsPostOrder"],[3,"Bfs"],[3,"ReversedEdgeRef"],[3,"ReversedEdgeReferences"],[8,"GraphBase"],[8,"IntoNeighbors"],[8,"IntoNeighborsDirected"],[8,"IntoNodeIdentifiers"],[8,"IntoExternals"],[8,"GraphEdgeRef"],[8,"EdgeRef"],[8,"IntoEdgeReferences"],[8,"NodeIndexable"],[8,"VisitMap"],[8,"Visitable"],[8,"GetAdjacencyMatrix"],[3,"DfsIter"],[3,"BfsIter"],[3,"Topo"],[3,"UnionFind"],[3,"Edge"],[3,"Node"],[8,"IndexType"],[8,"EdgeType"],[8,"IntoWeightedEdge"],[4,"Directed"],[4,"Undirected"],[3,"NodeIndex"],[3,"EdgeIndex"],[3,"Graph"],[3,"Externals"],[3,"Neighbors"],[3,"Edges"],[3,"NodeWeightsMut"],[3,"EdgeWeightsMut"],[3,"WalkNeighbors"],[3,"NodeIndices"],[3,"EdgeIndices"],[3,"EdgeReference"],[3,"EdgeReferences"],[3,"Frozen"]]};
searchIndex["fixedbitset"] = {"doc":"**FixedBitSet** is a simple fixed size set of bits.","items":[[3,"FixedBitSet","fixedbitset","**FixedBitSet** is a simple fixed size set of bits that can\nbe enabled (1 / **true**) or disabled (0 / **false**).",null,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"partial_cmp","","",0,null],[11,"lt","","",0,null],[11,"le","","",0,null],[11,"gt","","",0,null],[11,"ge","","",0,null],[11,"cmp","","",0,null],[11,"hash","","",0,null],[11,"default","","",0,{"inputs":[],"output":{"name":"fixedbitset"}}],[11,"with_capacity","","Create a new **FixedBitSet** with a specific number of bits,\nall initially clear.",0,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"grow","","Grow capacity to **bits**, all new bits initialized to zero",0,null],[11,"len","","Return the length of the **FixedBitSet** in bits.",0,null],[11,"contains","","Return **true** if the bit is enabled in the **FixedBitSet**,\n**false** otherwise.",0,null],[11,"clear","","Clear all bits.",0,null],[11,"insert","","Enable `bit`.",0,null],[11,"put","","Enable `bit`, and return its previous value.",0,null],[11,"set","","**Panics** if **bit** is out of bounds.",0,null],[11,"copy_bit","","Copies boolean value from specified bit to the specified bit.",0,null],[11,"as_slice","","View the bitset as a slice of `u32` blocks",0,null],[11,"as_mut_slice","","View the bitset as a mutable slice of `u32` blocks. Writing past the bitlength in the last\nwill cause `contains` to return potentially incorrect results for bits past the bitlength.",0,null],[11,"clone","","",0,null],[11,"index","","",0,null]],"paths":[[3,"FixedBitSet"]]};
initSearch(searchIndex);
